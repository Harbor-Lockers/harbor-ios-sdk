// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target arm64-apple-ios12.1-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name AnywhereLockerSDK
@_exported import AnywhereLockerSDK
import CoreGraphics.CGBase
import Combine
import CoreBluetooth
import CoreGraphics
import Foundation
import Swift
import UIKit
open class CBORDecoder {
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init()
  open func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
  @objc deinit
}
extension CBORDecoder : Combine.TopLevelDecoder {
  public typealias Input = Foundation.Data
}
@frozen public struct AnyDecodable : Swift.Decodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyDecodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension AnyDecodable : AnywhereLockerSDK._AnyDecodable {
}
extension _AnyDecodable {
  public init(from decoder: Swift.Decoder) throws
}
extension AnyDecodable : Swift.Equatable {
  public static func == (lhs: AnywhereLockerSDK.AnyDecodable, rhs: AnywhereLockerSDK.AnyDecodable) -> Swift.Bool
}
extension AnyDecodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AnyDecodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum PERSISTENCE_ERROR : Swift.Error {
  case PERSISTENCE_DELEGATE_NOT_SET
  case KEY_ALREADY_EXISTS
  case KEY_DOES_NOT_EXIST
  case KEY_IS_NOT_ALPHANUMERIC
  case STORAGE_DIRECTORY_ACCESS_FAILED
  case STORAGE_DIRECTORY_ALREADY_EXISTS
  case CONVERSION_STRING_DATA_FAILED
  public static func == (a: AnywhereLockerSDK.PERSISTENCE_ERROR, b: AnywhereLockerSDK.PERSISTENCE_ERROR) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol PersistenceDelegate : ObjectiveC.NSObject {
  func write(key: Swift.String, value: Foundation.Data, forced: Swift.Bool) throws
  func read(key: Swift.String) throws -> Foundation.Data?
  func getAllKeys() throws -> [Swift.String]
  func delete(key: Swift.String) throws
  func deleteAllKeys() throws
  func sizeOf(key: Swift.String) throws -> Swift.UInt64
  func sizeOfAllKeys() throws -> Swift.UInt64
}
@objc @_inheritsConvenienceInitializers public class PersistenceManager : ObjectiveC.NSObject {
  @objc override dynamic public init()
  public static func setDelegate(_ persistenceDelegate: AnywhereLockerSDK.PersistenceDelegate)
  public static func getDelegate() throws -> AnywhereLockerSDK.PersistenceDelegate
  @objc deinit
}
extension Data {
  public func cborHexStringFromJSON() -> Swift.String
  public func hexString() -> Swift.String
  public static func randomCryptoBytes(_ count: Swift.Int) throws -> Foundation.Data
  public init?(hexString: Swift.String)
}
extension CBOR.NegativeUInt64 : Swift.Equatable {
  public static func == (lhs: AnywhereLockerSDK.CBOR.NegativeUInt64, rhs: AnywhereLockerSDK.CBOR.NegativeUInt64) -> Swift.Bool
}
extension CBOR.SimpleValue : Swift.Equatable {
  public static func == (lhs: AnywhereLockerSDK.CBOR.SimpleValue, rhs: AnywhereLockerSDK.CBOR.SimpleValue) -> Swift.Bool
}
extension CBOR.Bignum : Swift.Equatable {
  public static func == (lhs: AnywhereLockerSDK.CBOR.Bignum, rhs: AnywhereLockerSDK.CBOR.Bignum) -> Swift.Bool
}
extension CBOR.DecimalFraction : Swift.Equatable {
  public static func == (lhs: AnywhereLockerSDK.CBOR.DecimalFraction<I1, I2>, rhs: AnywhereLockerSDK.CBOR.DecimalFraction<I1, I2>) -> Swift.Bool
}
extension CBOR.Bigfloat : Swift.Equatable {
  public static func == (lhs: AnywhereLockerSDK.CBOR.Bigfloat<I1, I2>, rhs: AnywhereLockerSDK.CBOR.Bigfloat<I1, I2>) -> Swift.Bool
}
extension CBOR.IndefiniteLengthArray : Swift.Equatable where Element : Swift.Equatable {
  public static func == (lhs: AnywhereLockerSDK.CBOR.IndefiniteLengthArray<Element>, rhs: AnywhereLockerSDK.CBOR.IndefiniteLengthArray<Element>) -> Swift.Bool
}
extension CBOR.IndefiniteLengthMap : Swift.Equatable where Value : Swift.Equatable {
  public static func == (lhs: AnywhereLockerSDK.CBOR.IndefiniteLengthMap<Key, Value>, rhs: AnywhereLockerSDK.CBOR.IndefiniteLengthMap<Key, Value>) -> Swift.Bool
}
extension CBOR.IndefiniteLengthData : Swift.Equatable {
  public static func == (lhs: AnywhereLockerSDK.CBOR.IndefiniteLengthData, rhs: AnywhereLockerSDK.CBOR.IndefiniteLengthData) -> Swift.Bool
}
extension CBOR.IndefiniteLengthString : Swift.Equatable {
  public static func == (lhs: AnywhereLockerSDK.CBOR.IndefiniteLengthString, rhs: AnywhereLockerSDK.CBOR.IndefiniteLengthString) -> Swift.Bool
}
public typealias BLEConnectionResult = Swift.Result<Swift.String, Swift.Error>
public typealias BLEResponseHandler = (Foundation.Data?, Swift.Error?) -> Swift.Void
public struct CBOR {
  public struct Undefined {
  }
  public struct NegativeUInt64 : Swift.RawRepresentable {
    public var rawValue: Swift.UInt64
    public init(rawValue: Swift.UInt64)
    public typealias RawValue = Swift.UInt64
  }
  public struct SimpleValue : Swift.RawRepresentable {
    public var rawValue: Swift.UInt8
    public init(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
  }
  public struct Bignum {
  }
  public struct DecimalFraction<I1, I2> where I1 : Swift.FixedWidthInteger, I2 : Swift.FixedWidthInteger {
  }
  public struct Bigfloat<I1, I2> where I1 : Swift.FixedWidthInteger, I2 : Swift.FixedWidthInteger {
  }
  public struct IndefiniteLengthArray<Element> {
    public var array: [Element]
    public init(wrapping array: [Element] = [])
  }
  public struct IndefiniteLengthMap<Key, Value> where Key : Swift.Hashable {
    public var map: [Key : Value]
    public init(wrapping map: [Key : Value] = [:])
  }
  public struct IndefiniteLengthData {
    public var chunks: [Foundation.Data]
    public init(wrapping chunks: [Foundation.Data] = [])
    public init(wrapping data: Foundation.Data = Data(), chunkSize: Swift.Int = 128)
  }
  public struct IndefiniteLengthString {
    public var chunks: [Foundation.Data]
    public var stringValue: Swift.String? {
      get
    }
    public init(wrapping chunks: [Swift.String] = [])
    public init(wrapping string: Swift.String = "", chunkSize: Swift.Int = 128)
  }
  public struct CBOREncoded {
    public let encodedData: Foundation.Data
    public init(encodedData: Foundation.Data)
  }
}
@frozen public struct Half {
  public var _value: AnywhereLockerSDK.half_t
  @_transparent public init() {
        self._value = _half_zero()
    }
  @_transparent public init(_ _value: AnywhereLockerSDK.half_t) {
        self._value = _value
    }
}
extension Half {
  @inlinable public var bitPattern: Swift.UInt16 {
    get {
        return _half_to_raw(_value)
    }
  }
  @inlinable public init(bitPattern: Swift.UInt16) {
        self._value = _half_from_raw(bitPattern)
    }
  @inlinable public init(nan payload: Swift.UInt16, signaling: Swift.Bool) {
        precondition(payload < (Half.quietNaNMask &>> 1), "NaN payload is not encodable.")

        var significand = payload
        significand |= Half.quietNaNMask &>> (signaling ? 1 : 0)

        self.init(sign: .plus, exponentBitPattern: Half.infinityExponent, significandBitPattern: significand)
    }
}
extension Half : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Half : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Half : Swift.TextOutputStreamable {
  public func write<Target>(to target: inout Target) where Target : Swift.TextOutputStream
}
extension Half {
  @inlinable @inline(__always) internal static var significandMask: Swift.UInt16 {
    get {
        return 1 &<< UInt16(significandBitCount) - 1
    }
  }
  @inlinable @inline(__always) internal static var infinityExponent: Swift.UInt {
    get {
        return 1 &<< UInt(exponentBitCount) - 1
    }
  }
  @inlinable @inline(__always) internal static var exponentBias: Swift.UInt {
    get {
        return infinityExponent &>> 1
    }
  }
  @inlinable @inline(__always) internal static var quietNaNMask: Swift.UInt16 {
    get {
        return 1 &<< UInt16(significandBitCount - 1)
    }
  }
}
extension Half : Swift.BinaryFloatingPoint {
  @inlinable public static var exponentBitCount: Swift.Int {
    get {
        return 5
    }
  }
  @inlinable public static var significandBitCount: Swift.Int {
    get {
        return 10
    }
  }
  @inlinable public var exponentBitPattern: Swift.UInt {
    get {
        return UInt(bitPattern &>> UInt16(Half.significandBitCount)) & Half.infinityExponent
    }
  }
  @inlinable public var significandBitPattern: Swift.UInt16 {
    get {
        return bitPattern & Half.significandMask
    }
  }
  @inlinable public init(sign: Swift.FloatingPointSign, exponentBitPattern: Swift.UInt, significandBitPattern: Swift.UInt16) {
        let signBits: UInt16 = (sign == .minus ? 1 : 0) &<< (Half.exponentBitCount + Half.significandBitCount)
        let exponentBits = UInt16((exponentBitPattern & Half.infinityExponent) &<< Half.significandBitCount)
        let significandBits = significandBitPattern & Half.significandMask

        self.init(bitPattern: signBits | exponentBits | significandBits)
    }
  @inlinable @inline(__always) public init(_ other: Swift.Float) {
        if other.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: other.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if other.isNaN {
            if other.isSignalingNaN {
                self = .signalingNaN
            } else {
                self = .nan
            }
        } else {
            _value = _half_from(other)
        }
    }
  @inlinable @inline(__always) public init(_ other: Swift.Double) {
        if other.isInfinite {
            let infinity = Half.infinity
            self = Half(sign: other.sign, exponentBitPattern: infinity.exponentBitPattern, significandBitPattern: infinity.significandBitPattern)
        } else if other.isNaN {
            if other.isSignalingNaN {
                self = .signalingNaN
            } else {
                self = .nan
            }
        } else {
            _value = _half_from(other)
        }
    }
  @inlinable @inline(__always) public init(_ other: CoreGraphics.CGFloat) {
        self.init(other.native)
    }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryFloatingPoint {
        if let half = value as? Half {
            self.init(half._value)
        } else {
            self.init(Float(value))
        }
    }
  @inlinable public init?<Source>(exactly value: Source) where Source : Swift.BinaryFloatingPoint {
        self.init(value)

        if isInfinite || value.isInfinite {
            if value.isInfinite && (!isInfinite || sign != value.sign) {
                // If source is infinite but this isn't or this is but with a different sign
                return nil
            } else if isInfinite && !value.isInfinite {
                // If source isn't infinite but this is
                return nil
            }
        } else if isNaN || value.isNaN {
            if value.isNaN && (!isNaN || isSignalingNaN != value.isSignalingNaN) {
                // If source is NaN but this isn't or this is but one is signaling while the other isn't
                return nil
            } else if isNaN && !value.isNaN {
                // If source isn't NaN but this is
                return nil
            }
        } else if Source(self) != value {
            // If casting half back to source isn't equal to original source
            return nil
        }
    }
  @inlinable public var binade: AnywhereLockerSDK.Half {
    get {
        guard isFinite else { return .nan }

        if isSubnormal {
            let bitPattern = (self * 0x1p10).bitPattern & (-Half.infinity).bitPattern
            return Half(bitPattern: bitPattern) * .ulpOfOne
        }

        return Half(bitPattern: bitPattern & (-Half.infinity).bitPattern)
    }
  }
  @inlinable public var significandWidth: Swift.Int {
    get {
        let trailingZeroBits = significandBitPattern.trailingZeroBitCount
        if isNormal {
            guard significandBitPattern != 0 else { return 0 }
            return Half.significandBitCount &- trailingZeroBits
        }
        if isSubnormal {
            let leadingZeroBits = significandBitPattern.leadingZeroBitCount
            return UInt16.bitWidth &- (trailingZeroBits &+ leadingZeroBits &+ 1)
        }
        return -1
    }
  }
  public typealias RawSignificand = Swift.UInt16
  public typealias RawExponent = Swift.UInt
}
extension Half : Swift.ExpressibleByFloatLiteral {
  @_transparent public init(floatLiteral value: Swift.Float) {
        self.init(value)
    }
  public typealias FloatLiteralType = Swift.Float
}
extension Half : Swift.FloatingPoint {
  @inlinable public init(sign: Swift.FloatingPointSign, exponent: Swift.Int, significand: AnywhereLockerSDK.Half) {
        var result = significand
        if sign == .minus { result = -result }

        if significand.isFinite && !significand.isZero {
            var clamped = exponent
            let leastNormalExponent = 1 - Int(Half.exponentBias)
            let greatestFiniteExponent = Int(Half.exponentBias)

            if clamped < leastNormalExponent {
                clamped = max(clamped, 3 * leastNormalExponent)

                while clamped < leastNormalExponent {
                    result *= Half.leastNormalMagnitude
                    clamped -= leastNormalExponent
                }
            } else if clamped > greatestFiniteExponent {
                let step = Half(sign: .plus, exponentBitPattern: Half.infinityExponent - 1, significandBitPattern: 0)
                clamped = min(clamped, 3 * greatestFiniteExponent)

                while clamped > greatestFiniteExponent {
                    result *= step
                    clamped -= greatestFiniteExponent
                }
            }

            let scale = Half(sign: .plus, exponentBitPattern: UInt(Int(Half.exponentBias) + clamped), significandBitPattern: 0)
            result *= scale
        }

        self = result
    }
  @_transparent public init(_ value: Swift.Int) {
        _value = _half_from(value)
    }
  @inlinable @inline(__always) public init<Source>(_ value: Source) where Source : Swift.BinaryInteger {
        if value.bitWidth <= MemoryLayout<Int>.size * 8 {
            if Source.isSigned {
                let asInt = Int(truncatingIfNeeded: value)
                self.init(_half_from(asInt))
            } else {
                let asUInt = UInt(truncatingIfNeeded: value)
                self.init(_half_from(asUInt))
            }
        } else {
            self.init(Float(value))
        }
    }
  @inlinable public var exponent: Swift.Int {
    get {
        if !isFinite { return .max }
        if isZero { return .min }

        let provisional = Int(exponentBitPattern) - Int(Half.exponentBias)
        if isNormal { return provisional }

        let shift = Half.significandBitCount - Int(significandBitPattern._binaryLogarithm())
        return provisional + 1 - shift
    }
  }
  @inlinable public var isCanonical: Swift.Bool {
    get {

        return true
    }
  }
  @inlinable @inline(__always) public var isFinite: Swift.Bool {
    get {
        return exponentBitPattern < Half.infinityExponent
    }
  }
  @inlinable @inline(__always) public var isInfinite: Swift.Bool {
    get {
        return !isFinite && significandBitPattern == 0
    }
  }
  @inlinable @inline(__always) public var isNaN: Swift.Bool {
    get {
        return !isFinite && significandBitPattern != 0
    }
  }
  @inlinable @inline(__always) public var isNormal: Swift.Bool {
    get {
        return exponentBitPattern > 0 && isFinite
    }
  }
  @inlinable @inline(__always) public var isSignalingNaN: Swift.Bool {
    get {
        return isNaN && (significandBitPattern & Half.quietNaNMask) == 0
    }
  }
  @inlinable @inline(__always) public var isSubnormal: Swift.Bool {
    get {
        return exponentBitPattern == 0 && significandBitPattern != 0
    }
  }
  @inlinable @inline(__always) public var isZero: Swift.Bool {
    get {
        return exponentBitPattern == 0 && significandBitPattern == 0
    }
  }
  @inlinable public var nextUp: AnywhereLockerSDK.Half {
    get {
        let next = self + 0


        if next < .infinity {
            let increment = Int16(bitPattern: next.bitPattern) &>> 15 | 1
            let bitPattern = next.bitPattern &+ UInt16(bitPattern: increment)
            return Half(bitPattern: bitPattern)
        }

        return next
    }
  }
  @inlinable public var sign: Swift.FloatingPointSign {
    get {
        let shift = Half.significandBitCount + Half.exponentBitCount
        //swiftlint:disable force_unwrapping
        return FloatingPointSign(rawValue: Int(bitPattern &>> UInt16(shift)))!
        //swiftlint:enable force_unwrapping
    }
  }
  @inlinable public var significand: AnywhereLockerSDK.Half {
    get {
        if isNaN { return self }
        if isNormal {
            return Half(sign: .plus, exponentBitPattern: Half.exponentBias, significandBitPattern: significandBitPattern)
        }

        if isSubnormal {
            let shift = Half.significandBitCount - Int(significandBitPattern._binaryLogarithm())
            return Half(sign: .plus, exponentBitPattern: Half.exponentBias, significandBitPattern: significandBitPattern &<< shift)
        }

        return Half(sign: .plus, exponentBitPattern: exponentBitPattern, significandBitPattern: 0)
    }
  }
  @inlinable public var ulp: AnywhereLockerSDK.Half {
    get {
        guard isFinite else { return .nan }
        if isNormal {
            let bitPattern = self.bitPattern & Half.infinity.bitPattern
            return Half(bitPattern: bitPattern) * .ulpOfOne
        }

        return .leastNormalMagnitude * .ulpOfOne
    }
  }
  @inlinable public static var greatestFiniteMagnitude: AnywhereLockerSDK.Half {
    get {
        return Half(bitPattern: 0x7BFF)
    }
  }
  @inlinable public static var infinity: AnywhereLockerSDK.Half {
    get {
        return Half(bitPattern: 0x7C00)
    }
  }
  @inlinable public static var leastNonzeroMagnitude: AnywhereLockerSDK.Half {
    get {
        return Half(sign: .plus, exponentBitPattern: 0, significandBitPattern: 1)
    }
  }
  @inlinable public static var leastNormalMagnitude: AnywhereLockerSDK.Half {
    get {
        return Half(sign: .plus, exponentBitPattern: 1, significandBitPattern: 0)
    }
  }
  @inlinable public static var nan: AnywhereLockerSDK.Half {
    get {
        return Half(_half_nan())
    }
  }
  @inlinable public static var pi: AnywhereLockerSDK.Half {
    get {
        return Half(_half_pi())
    }
  }
  @inlinable public static var signalingNaN: AnywhereLockerSDK.Half {
    get {
        return Half(nan: 0, signaling: true)
    }
  }
  @inlinable public static var ulpOfOne: AnywhereLockerSDK.Half {
    get {
        return Half(_half_epsilon())
    }
  }
  @_transparent public mutating func addProduct(_ lhs: AnywhereLockerSDK.Half, _ rhs: AnywhereLockerSDK.Half) {
        _value = _half_fma(_value, lhs._value, rhs._value)
    }
  @inlinable @inline(__always) public mutating func formRemainder(dividingBy other: AnywhereLockerSDK.Half) {
        self = Half(Float(self).remainder(dividingBy: Float(other)))
    }
  @_transparent public mutating func formSquareRoot() {
        _value = _half_sqrt(_value)
    }
  @inlinable @inline(__always) public mutating func formTruncatingRemainder(dividingBy other: AnywhereLockerSDK.Half) {
        self = Half(Float(self).truncatingRemainder(dividingBy: Float(other)))
    }
  @_transparent public func isEqual(to other: AnywhereLockerSDK.Half) -> Swift.Bool {
        return Bool(_half_equal(self._value, other._value))
    }
  @_transparent public func isLess(than other: AnywhereLockerSDK.Half) -> Swift.Bool {
        return Bool(_half_lt(self._value, other._value))
    }
  @_transparent public func isLessThanOrEqualTo(_ other: AnywhereLockerSDK.Half) -> Swift.Bool {
        return Bool(_half_lte(self._value, other._value))
    }
  @_transparent public mutating func round(_ rule: Swift.FloatingPointRoundingRule) {
        self = Half(Float(self).rounded(rule))
    }
  @_transparent public static func / (lhs: AnywhereLockerSDK.Half, rhs: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
        return Half(_half_div(lhs._value, rhs._value))
    }
  @_transparent public static func /= (lhs: inout AnywhereLockerSDK.Half, rhs: AnywhereLockerSDK.Half) {
        lhs._value = _half_div(lhs._value, rhs._value)
    }
  public typealias Exponent = Swift.Int
}
extension Half : Swift.Hashable {
  @inlinable public func hash(into hasher: inout Swift.Hasher) {
        var value = self
        if isZero {
            value = 0 // to reconcile -0.0 and +0.0
        }

        hasher.combine(value.bitPattern)
    }
  public var hashValue: Swift.Int {
    get
  }
}
extension Half : Swift.Strideable {
  @_transparent public func distance(to other: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
        return other - self
    }
  @_transparent public func advanced(by amount: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
        return self + amount
    }
  public typealias Stride = AnywhereLockerSDK.Half
}
extension Half : Swift.SignedNumeric {
  @_transparent public mutating func negate() {
        _value = _half_neg(_value)
    }
  @_transparent prefix public static func - (value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
        return Half(_half_neg(value._value))
    }
}
extension Half : Swift.Numeric {
  @inlinable @inline(__always) public var magnitude: AnywhereLockerSDK.Half {
    get {
        return Half(_half_abs(_value))
    }
  }
  @inlinable @inline(__always) public init?<Source>(exactly value: Source) where Source : Swift.BinaryInteger {
        self.init(value)

        if isInfinite || isNaN || Source(self) != value {
            return nil
        }
    }
  @_transparent public static func * (lhs: AnywhereLockerSDK.Half, rhs: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
        return Half(_half_mul(lhs._value, rhs._value))
    }
  @_transparent public static func *= (lhs: inout AnywhereLockerSDK.Half, rhs: AnywhereLockerSDK.Half) {
        lhs._value = _half_mul(lhs._value, rhs._value)
    }
  public typealias Magnitude = AnywhereLockerSDK.Half
}
extension Half : Swift.ExpressibleByIntegerLiteral {
  @_transparent public init(integerLiteral value: Swift.Int64) {
        self = Half(value)
    }
  public typealias IntegerLiteralType = Swift.Int64
}
extension Half : Swift.AdditiveArithmetic {
  @_transparent public static func + (lhs: AnywhereLockerSDK.Half, rhs: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
        return Half(_half_add(lhs._value, rhs._value))
    }
  @_transparent public static func += (lhs: inout AnywhereLockerSDK.Half, rhs: AnywhereLockerSDK.Half) {
        lhs._value = _half_add(lhs._value, rhs._value)
    }
  @_transparent public static func - (lhs: AnywhereLockerSDK.Half, rhs: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
        return Half(_half_sub(lhs._value, rhs._value))
    }
  @_transparent public static func -= (lhs: inout AnywhereLockerSDK.Half, rhs: AnywhereLockerSDK.Half) {
        lhs._value = _half_sub(lhs._value, rhs._value)
    }
}
extension Half : Swift.CustomReflectable {
  @_transparent public var customMirror: Swift.Mirror {
    @_transparent get {
        return Mirror(reflecting: Float(self))
    }
  }
}
extension Half : Swift.CustomPlaygroundDisplayConvertible {
  @_transparent public var playgroundDescription: Any {
    @_transparent get {
        return Float(self)
    }
  }
}
@_transparent public func acos(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(acos(Float(value)))
}
@_transparent public func acosh(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(acosh(Float(value)))
}
@_transparent public func asin(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(asin(Float(value)))
}
@_transparent public func asinh(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(asinh(Float(value)))
}
@_transparent public func atan(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(atan(Float(value)))
}
@_transparent public func atanh(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(atanh(Float(value)))
}
@_transparent public func cbrt(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(cbrt(Float(value)))
}
@_transparent public func cos(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(cos(Float(value)))
}
@_transparent public func cosh(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(cosh(Float(value)))
}
@_transparent public func erf(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(erf(Float(value)))
}
@_transparent public func erfc(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(erfc(Float(value)))
}
@_transparent public func exp(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(exp(Float(value)))
}
@_transparent public func exp2(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(exp2(Float(value)))
}
@_transparent public func expm1(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(expm1(Float(value)))
}
@_transparent public func log(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(log(Float(value)))
}
@_transparent public func log10(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(log10(Float(value)))
}
@_transparent public func log1p(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(log1p(Float(value)))
}
@_transparent public func log2(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(log2(Float(value)))
}
@_transparent public func logb(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(logb(Float(value)))
}
@_transparent public func nearbyint(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(nearbyint(Float(value)))
}
@_transparent public func rint(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(rint(Float(value)))
}
@_transparent public func sin(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(sin(Float(value)))
}
@_transparent public func sinh(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(sinh(Float(value)))
}
@_transparent public func tan(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(tan(Float(value)))
}
@_transparent public func tanh(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(tanh(Float(value)))
}
@_transparent public func tgamma(_ value: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(tgamma(Float(value)))
}
@_transparent public func atan2(_ lhs: AnywhereLockerSDK.Half, _ rhs: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(atan2(Float(lhs), Float(rhs)))
}
@_transparent public func copysign(_ lhs: AnywhereLockerSDK.Half, _ rhs: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(copysign(Float(lhs), Float(rhs)))
}
@_transparent public func fdim(_ lhs: AnywhereLockerSDK.Half, _ rhs: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(fdim(Float(lhs), Float(rhs)))
}
@_transparent public func fmax(_ lhs: AnywhereLockerSDK.Half, _ rhs: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(fmax(Float(lhs), Float(rhs)))
}
@_transparent public func fmin(_ lhs: AnywhereLockerSDK.Half, _ rhs: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(fmin(Float(lhs), Float(rhs)))
}
@_transparent public func hypot(_ lhs: AnywhereLockerSDK.Half, _ rhs: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(hypot(Float(lhs), Float(rhs)))
}
@_transparent public func nextafter(_ lhs: AnywhereLockerSDK.Half, _ rhs: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(nextafter(Float(lhs), Float(rhs)))
}
@_transparent public func pow(_ lhs: AnywhereLockerSDK.Half, _ rhs: AnywhereLockerSDK.Half) -> AnywhereLockerSDK.Half {
    return Half(pow(Float(lhs), Float(rhs)))
}
@_transparent public func lgamma(_ value: AnywhereLockerSDK.Half) -> (AnywhereLockerSDK.Half, Swift.Int) {
    let result = lgamma(Float(value))
    return (Half(result.0), result.1)
}
@_transparent public func remquo(_ lhs: AnywhereLockerSDK.Half, _ rhs: AnywhereLockerSDK.Half) -> (AnywhereLockerSDK.Half, Swift.Int) {
    let result = remquo(Float(lhs), Float(rhs))
    return (Half(result.0), result.1)
}
open class CBOREncoder {
  public enum DateEncodingStrategy {
    case rfc3339
    case secondsSince1970
    public static func == (a: AnywhereLockerSDK.CBOREncoder.DateEncodingStrategy, b: AnywhereLockerSDK.CBOREncoder.DateEncodingStrategy) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  open var dateEncodingStrategy: AnywhereLockerSDK.CBOREncoder.DateEncodingStrategy
  open var includeCBORTag: Swift.Bool
  open var keySorter: ((Any, Any) -> Swift.Bool)?
  open var userInfo: [Swift.CodingUserInfoKey : Any]
  public init()
  open func encode<T>(_ value: T) throws -> Foundation.Data where T : Swift.Encodable
  @objc deinit
}
public protocol CBOREncoderProtocol : Swift.Encoder {
  func indefiniteLengthContainerContext<R>(includingSubcontainers: Swift.Bool, _ block: () throws -> R) rethrows -> R
  func definiteLengthContainerContext<R>(includingSubcontainers: Swift.Bool, _ block: () throws -> R) rethrows -> R
}
extension CBOREncoderProtocol {
  public func indefiniteLengthContainerContext<R>(includingSubcontainers flag: Swift.Bool = false, _ block: () throws -> R) rethrows -> R
  public func definiteLengthContainerContext<R>(includingSubcontainers flag: Swift.Bool = false, _ block: () throws -> R) rethrows -> R
}
extension CBOREncoder : Combine.TopLevelEncoder {
  public typealias Output = Foundation.Data
}
public protocol LALSDKConsole {
  func printToConsole(_ string: Swift.String)
}
@objc @_inheritsConvenienceInitializers public class LALSDK : ObjectiveC.NSObject {
  public static let shared: AnywhereLockerSDK.LALSDK
  public var outputConsole: AnywhereLockerSDK.LALSDKConsole? {
    get
    set
  }
  public func startNordicUart(outputConsole: AnywhereLockerSDK.LALSDKConsole?, completion: @escaping (AnywhereLockerSDK.BLEConnectionResult) -> Swift.Void)
  @objc override dynamic public init()
  @objc deinit
}
extension LALSDK {
  public func sendData(_ data: Foundation.Data)
  public func sendRequestSession(sessionMac: Foundation.Data)
  public func sendSyncStatus(firstEventId: Swift.UInt32, eventsCount: Swift.Int)
  public func sendSyncPull(firstEventId: Swift.UInt32?, eventsCountMax: Swift.Int?)
  public func sendMarkEventSyncCounter(firstEventId: Swift.UInt32)
  public func sendRequestLockerAvailability()
  public func sendOpenLocker(lockerId: Swift.Int? = nil, lockerType: Swift.Int? = nil, reopenWindow: Swift.Int? = nil)
  public func sendReopenLocker(lockerId: Swift.Int, reopenToken: Foundation.Data)
}
public struct Delivery : Swift.Codable {
  public let id: Swift.String?
  public let accessCode: Swift.String?
  public let pickupToken: Swift.String?
  public let locationId: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@frozen public struct AnyCodable : Swift.Codable {
  public let value: Any
  public init<T>(_ value: T?)
}
extension AnyCodable : AnywhereLockerSDK._AnyEncodable, AnywhereLockerSDK._AnyDecodable {
}
extension AnyCodable : Swift.Equatable {
  public static func == (lhs: AnywhereLockerSDK.AnyCodable, rhs: AnywhereLockerSDK.AnyCodable) -> Swift.Bool
}
extension AnyCodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AnyCodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension AnyCodable : Swift.ExpressibleByNilLiteral {
}
extension AnyCodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension AnyCodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension AnyCodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension AnyCodable : Swift.ExpressibleByStringLiteral {
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension AnyCodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension AnyCodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
extension CBOR.Undefined : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension CBOR.NegativeUInt64 : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension CBOR.SimpleValue : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension CBOR.Bignum : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension CBOR.DecimalFraction : Swift.Encodable where I1 : Swift.Encodable, I2 : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension CBOR.DecimalFraction : Swift.Decodable where I1 : Swift.Decodable, I2 : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension CBOR.Bigfloat : Swift.Encodable where I1 : Swift.Encodable, I2 : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension CBOR.Bigfloat : Swift.Decodable where I1 : Swift.Decodable, I2 : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension CBOR.IndefiniteLengthArray : Swift.Encodable where Element : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension CBOR.IndefiniteLengthArray : Swift.Decodable where Element : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension CBOR.IndefiniteLengthMap : Swift.Encodable where Key : Swift.Encodable, Value : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension CBOR.IndefiniteLengthMap : Swift.Decodable where Key : Swift.Decodable, Value : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension CBOR.IndefiniteLengthData : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension CBOR.IndefiniteLengthString : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension CBOR.CBOREncoded : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@frozen public struct AnyEncodable : Swift.Encodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyEncodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension AnyEncodable : AnywhereLockerSDK._AnyEncodable {
}
extension _AnyEncodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension AnyEncodable : Swift.Equatable {
  public static func == (lhs: AnywhereLockerSDK.AnyEncodable, rhs: AnywhereLockerSDK.AnyEncodable) -> Swift.Bool
}
extension AnyEncodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AnyEncodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension AnyEncodable : Swift.ExpressibleByNilLiteral {
}
extension AnyEncodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension AnyEncodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension AnyEncodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension AnyEncodable : Swift.ExpressibleByStringLiteral {
  public typealias StringLiteralType = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension AnyEncodable : Swift.ExpressibleByStringInterpolation {
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
}
extension AnyEncodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension AnyEncodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
extension _AnyEncodable {
  public init(nilLiteral _: ())
  public init(booleanLiteral value: Swift.Bool)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(arrayLiteral elements: Any...)
  public init(dictionaryLiteral elements: (Swift.AnyHashable, Any)...)
}
extension Half : Swift.Codable {
  @_transparent public init(from decoder: Swift.Decoder) throws {
        let container = try decoder.singleValueContainer()
        let float = try container.decode(Float.self)

        guard float.isInfinite || float.isNaN || abs(float) <= Float(Half.greatestFiniteMagnitude) else {
            throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: container.codingPath, debugDescription: "Parsed number \(float) does not fit in \(type(of: self))."))
        }

        self.init(float)
    }
  @_transparent public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(Float(self))
    }
}
extension AnywhereLockerSDK.PERSISTENCE_ERROR : Swift.Equatable {}
extension AnywhereLockerSDK.PERSISTENCE_ERROR : Swift.Hashable {}
extension AnywhereLockerSDK.CBOREncoder.DateEncodingStrategy : Swift.Equatable {}
extension AnywhereLockerSDK.CBOREncoder.DateEncodingStrategy : Swift.Hashable {}
